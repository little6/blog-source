title: "简述HTTP协议"
date: 2013-01-06
tags: http
---
## 什么是协议？

通俗的理解，协议就是双方为了交流而制定的标准，是一种约定的通信方式。就比如我们常说的“点头Yes摇头No”，这就是一种公共的交流协议。网络协议当然是为了在网络上通信而制定的一些标准，比如采用什么端口号，传递什么样的数据，数据采用什么样的格式进行组织等。

TCP/IP协议是个网络协议族。根据TCP/IP网络模型，将网络由低到高分为4层：网络接口层、网络层、传输层、应用层， 在每个层上都有不同的协议进行数据传输。比如，在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议；在传输层中有TCP协议与UDP协议；在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。

HTTP全称是超文本传输（转换）协议，是互联网上信息交换的基础。<!--more-->

## HTTP通信过程简述

HTTP是应用层的协议，应用层在传输层之上，传输层在网络层之上。所以一次HTTP请求时，数据先被包装成HTTP数据包，然后包装成TCP数据包，再包装成IP数据包后完成发送。如下图所示：

![](/images/http-route.jpg)


如图，当发起一次HTTP请求的时候，会将请求封装成http数据包，然后封装成Tcp数据包，再封装成Ip数据包， 通过物理硬件（网卡芯片）发生到指定地点，收到方先发现收到的是个ip数据包，所以通过ip协议解析Ip数据包，然后又发现里面是tcp数据包，就通过 tcp协议解析Tcp数据包，接着发现是http数据包通过http协议再解析http数据包得到数据。

了解了HTTP通信的大致流程，再来看HTTP的数据交换格式。下面分别来看请求和响应2部分数据格式。

### 请求报文格式（Request）

请求信息包含请求行、请求头、空行、可选消息体4个部分，下面截图展示了一个HTTP请求报文：

![](/images/http-request.jpg)

#### 请求行

例如上图： POST /JS3/SERVICE_BACK….   HTTP/1.1 \r\n
请求行里面主要包括 请求方法， 请求url 已经http版本号

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

- OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。
- GET：向特定的资源发出请求。
- POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
- PUT：向指定资源位置上传其最新内容。
- DELETE：请求服务器删除Request-URI所标识的资源。
- TRACE：回显服务器收到的请求，主要用于测试或诊断。
- CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

#### 请求头标

由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔。请求头标通知服务器有关于客户端的功能和标识，典型的请求头标有：

- User-Agent 客户端厂家和版本
- Accept 客户端可识别的内容类型列表
- Content-Length 附加到请求的数据字节数

在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。

#### 空行

最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标。

#### 请求数据

使用POST传送数据，最常使用的是Content-Type和Content-Length头标。

### 响应报文格式

​一个响应信息主要包括  状态行，响应头标，空行，响应数。下图展示了一次HTTP响应报文：

![](/images/http-response.jpg)

状态行： http版本号，状态码

状态码分类，状态代码的第一个数字代表当前响应的类型：

- 1xx - 消息，请求已被服务器接收，继续处理
- 2xx - 成功，请求已成功被服务器接收、理解、并接受
- 3xx - 重定向，需要后续操作才能完成这一请求
- 4xx - 请求错误，请求含有词法错误或者无法被执行
- 5xx - 服务器错误，服务器在处理某个正确请求时发生错误

#### 响应头

像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。

#### 空行

最后一个响应头之后是一个空行，以后便是数据本身。

#### 响应数据

HTML文档和图像等，也就是HTML本身。

## HTTP各个版本

Http0.9：已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息

HTTP/1.0：这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

HTTP/1.1：当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：

- 缓存处理
- 带宽优化及网络连接的使用
- 错误通知的管理
- 消息在网络中的发送
- 互联网地址的维护
- 安全性及完整性

![](/images/http-persistent-connection.png)

上图是HTTP1.0和HTTP1.1的短链接和长连接图请求响应图。在Http1.0中 ， 访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和 下一次请求完全分离，也就是说在性能方面都有很大的影响。

为了克服http1.0这种缺陷，HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和 应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

## 常见的缓存指令

### Cache-Control

Cache-Control 用于指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

Cache-Control 的值在请求和响应时会有所不同，请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if- cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must- revalidate、proxy-revalidate、max-age。

各个指令值的用途如下：
- public - 指示响应可被任何缓存区缓存。
- private - 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
- no-cache - 指示请求或响应消息不能缓存
- no-store - 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
- max-age - 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
- in-fresh - 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
- max-stale - 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

说明：max-age=8表示最大生存期8秒，超过8秒浏览器必须去服务器重新读取，这个时间是以用户的读取页面开始计时的。

### Last-Modified

标识文档的最后修改时间。当浏览器第一次请求某个URL时，服务端会在Response报文头中用last-modified标识该文档的最后修改时间。格式类似于：Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT

当浏览器第二次请求该URL时，会发送请求头 If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT。服务端会根据这个请求头判断，如果资源没有修改，则直接返回状态码304；如果资源发生了变化，则重新发送资源。

### Expires

Expires 指定了缓存过期的绝对时间，如果过了它指定的那个时间点，浏览器就不认缓存了，要去服务器重新请求一份最新的。

Expires 要和 Last-Modified 结合使用。当用户按了浏览器的刷新按钮或者按了F5，即使是标识了Expires的URL，浏览器也会重新发送一次请求。而对于标识了Last-Modified的URL，发请求后，服务器会对没有变化的资源返回304状态码，而不会重复下载资源。

如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。

Expires =max-age + “每次下载时的当前的request时间”，所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化。

​本文多数内容摘自一下文章：

- [http://lrysir.iteye.com/blog/1152071](http://lrysir.iteye.com/blog/1152071)
- [http://blog.csdn.net/eroswang/article/details/8302191"](http://blog.csdn.net/eroswang/article/details/8302191)

